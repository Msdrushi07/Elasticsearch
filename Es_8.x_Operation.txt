Perfect üëç Rushi! Let‚Äôs go step-by-step ‚Äî I‚Äôll show you a complete mini-project (Spring Boot + Elasticsearch Java Client) that includes create, update, get, search, delete operations ‚Äî just like what you might see in a real enterprise setup (like Deloitte or Citi projects).


---

üöÄ Project Overview

Tech Stack:

Java 17+

Spring Boot 3.x

Elasticsearch 8.x

Elasticsearch Java API Client (official)

Maven


Modules Covered: ‚úÖ ES Configuration
‚úÖ ES Utility (ESUtil)
‚úÖ CRUD Operations
‚úÖ Search (match, fuzzy, prefix)
‚úÖ REST Controller


---

üß± 1Ô∏è‚É£ pom.xml (Dependencies)

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Elasticsearch Java API Client -->
    <dependency>
        <groupId>co.elastic.clients</groupId>
        <artifactId>elasticsearch-java</artifactId>
        <version>8.12.2</version>
    </dependency>

    <dependency>
        <groupId>org.apache.httpcomponents.client5</groupId>
        <artifactId>httpclient5</artifactId>
        <version>5.3</version>
    </dependency>

    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>

</dependencies>


---

‚öôÔ∏è 2Ô∏è‚É£ application.yml

spring:
  application:
    name: elasticsearch-demo

elasticsearch:
  host: localhost
  port: 9200
  username: elastic
  password: your_password


---

üß© 3Ô∏è‚É£ Configuration ‚Äî ElasticsearchConfig.java

package com.elasticsearch.config;

import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.transport.TransportUtils;
import co.elastic.clients.transport.rest_client.RestClientTransport;
import co.elastic.clients.json.jackson.JacksonJsonpMapper;
import org.apache.http.auth.AuthScope;
import org.apache.http.auth.UsernamePasswordCredentials;
import org.apache.http.impl.client.BasicCredentialsProvider;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;
import org.elasticsearch.client.RestClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ElasticsearchConfig {

    @Value("${elasticsearch.host}")
    private String host;

    @Value("${elasticsearch.port}")
    private int port;

    @Value("${elasticsearch.username}")
    private String username;

    @Value("${elasticsearch.password}")
    private String password;

    @Bean
    public ElasticsearchClient elasticsearchClient() {
        BasicCredentialsProvider creds = new BasicCredentialsProvider();
        creds.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(username, password.toCharArray()));

        RestClient restClient = RestClient.builder(new org.apache.http.HttpHost(host, port, "http"))
                .setHttpClientConfigCallback((HttpAsyncClientBuilder httpClientBuilder) ->
                        httpClientBuilder.setDefaultCredentialsProvider(creds))
                .build();

        RestClientTransport transport = new RestClientTransport(restClient, new JacksonJsonpMapper());
        return new ElasticsearchClient(transport);
    }
}


---

üîß 4Ô∏è‚É£ Utility Class ‚Äî ESUtil.java

This is what your current project probably uses!

package com.elasticsearch.util;

import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.elasticsearch.core.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@Component
public class ESUtil {

    @Autowired
    private ElasticsearchClient client;

    // Index (Create/Update)
    public String indexDocument(String index, String id, Object document) throws IOException {
        IndexResponse response = client.index(i -> i
                .index(index)
                .id(id)
                .document(document)
        );
        return response.result().jsonValue();
    }

    // Get
    public <T> T getDocument(String index, String id, Class<T> clazz) throws IOException {
        GetResponse<T> response = client.get(g -> g.index(index).id(id), clazz);
        return response.found() ? response.source() : null;
    }

    // Update (partial)
    public void updateDocument(String index, String id, Map<String, Object> updateMap) throws IOException {
        UpdateRequest<Object, Object> request = new UpdateRequest.Builder<>()
                .index(index)
                .id(id)
                .doc(updateMap)
                .build();
        client.update(request, Object.class);
    }

    // Delete
    public void deleteDocument(String index, String id) throws IOException {
        client.delete(d -> d.index(index).id(id));
    }

    // Search (match query)
    public <T> List<T> searchByField(String index, String field, String value, Class<T> clazz) throws IOException {
        SearchResponse<T> response = client.search(s -> s
                        .index(index)
                        .query(q -> q.match(m -> m.field(field).query(value))),
                clazz);

        return response.hits().hits().stream()
                .map(hit -> hit.source())
                .toList();
    }
}


---

üßç 5Ô∏è‚É£ Model ‚Äî Employee.java

package com.elasticsearch.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Employee {
    private String id;
    private String name;
    private String designation;
    private List<String> skills;
}


---

üíº 6Ô∏è‚É£ Service ‚Äî EmployeeService.java

package com.elasticsearch.service;

import com.elasticsearch.entity.Employee;
import com.elasticsearch.util.ESUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@Service
public class EmployeeService {

    private static final String INDEX = "employees";

    @Autowired
    private ESUtil esUtil;

    public String saveEmployee(Employee emp) throws IOException {
        return esUtil.indexDocument(INDEX, emp.getId(), emp);
    }

    public Employee getEmployee(String id) throws IOException {
        return esUtil.getDocument(INDEX, id, Employee.class);
    }

    public void updateEmployee(String id, Map<String, Object> updateFields) throws IOException {
        esUtil.updateDocument(INDEX, id, updateFields);
    }

    public void deleteEmployee(String id) throws IOException {
        esUtil.deleteDocument(INDEX, id);
    }

    public List<Employee> searchByName(String name) throws IOException {
        return esUtil.searchByField(INDEX, "name", name, Employee.class);
    }
}


---

üåê 7Ô∏è‚É£ Controller ‚Äî EmployeeController.java

package com.elasticsearch.controller;

import com.elasticsearch.entity.Employee;
import com.elasticsearch.service.EmployeeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/employees")
public class EmployeeController {

    @Autowired
    private EmployeeService service;

    @PostMapping
    public String save(@RequestBody Employee emp) throws IOException {
        return service.saveEmployee(emp);
    }

    @GetMapping("/{id}")
    public Employee get(@PathVariable String id) throws IOException {
        return service.getEmployee(id);
    }

    @PatchMapping("/{id}")
    public String update(@PathVariable String id, @RequestBody Map<String, Object> updateFields) throws IOException {
        service.updateEmployee(id, updateFields);
        return "Updated successfully";
    }

    @DeleteMapping("/{id}")
    public String delete(@PathVariable String id) throws IOException {
        service.deleteEmployee(id);
        return "Deleted successfully";
    }

    @GetMapping("/search")
    public List<Employee> search(@RequestParam String name) throws IOException {
        return service.searchByName(name);
    }
}


---

üß™ 8Ô∏è‚É£ Sample Test with curl or Postman

‚ûï Add Employee

POST http://localhost:8080/api/employees
{
  "id": "1",
  "name": "Rushi",
  "designation": "Developer",
  "skills": ["Spring Boot", "Docker"]
}

üîç Get Employee

GET http://localhost:8080/api/employees/1

üîÑ Update Employee

PATCH http://localhost:8080/api/employees/1
{
  "designation": "Senior Developer"
}

‚ùå Delete Employee

DELETE http://localhost:8080/api/employees/1

üîé Search

GET http://localhost:8080/api/employees/search?name=Rushi


---

üß≠ That‚Äôs It!

You now have a complete Spring Boot + Elasticsearch Java Client project that mirrors how large-scale applications work ‚Äî using a utility layer (ESUtil) instead of repositories.


---

Would you like me to extend this example to include:

Fuzzy search, autocomplete, and bulk indexing/search (for real-world cases like skills and suggestions)?
That‚Äôs typically the next level after this foundation.


