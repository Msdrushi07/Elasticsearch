Perfect ‚úÖ Rushi ‚Äî that‚Äôs an excellent approach üëè
Let‚Äôs first master Elasticsearch 7.x operations using the RestHighLevelClient, because this is what most enterprise projects (like Deloitte, Citi, Travelers, etc.) still use internally.

We‚Äôll go step-by-step and cover all major operations:
üß± Index (create/update), üîç Get, üîÑ Update (partial), ‚ùå Delete, and üîé Search ‚Äî just like in real projects.


---

üöÄ Project Overview (Elasticsearch 7.x)

Tech stack:

Java 17+

Spring Boot 2.7.x (or 3.x with ES 7 client)

Elasticsearch 7.x server

Maven



---

üß© 1Ô∏è‚É£ pom.xml

Add these dependencies:

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Elasticsearch High-Level REST Client -->
    <dependency>
        <groupId>org.elasticsearch.client</groupId>
        <artifactId>elasticsearch-rest-high-level-client</artifactId>
        <version>7.17.5</version>
    </dependency>

    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpclient</artifactId>
        <version>4.5.13</version>
    </dependency>

    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>
</dependencies>


---

‚öôÔ∏è 2Ô∏è‚É£ Configuration ‚Äî ElasticsearchConfig.java

package com.elasticsearch.config;

import org.apache.http.HttpHost;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestHighLevelClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ElasticsearchConfig {

    @Bean(destroyMethod = "close")
    public RestHighLevelClient restHighLevelClient() {
        return new RestHighLevelClient(
                RestClient.builder(new HttpHost("localhost", 9200, "http"))
        );
    }
}


---

üß± 3Ô∏è‚É£ Model ‚Äî Employee.java

package com.elasticsearch.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Employee {
    private String id;
    private String name;
    private String designation;
    private List<String> skills;
}


---

üîß 4Ô∏è‚É£ Utility ‚Äî ESUtil.java

This is where all core Elasticsearch 7.x operations live üëá

package com.elasticsearch.util;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.elasticsearch.action.delete.DeleteRequest;
import org.elasticsearch.action.delete.DeleteResponse;
import org.elasticsearch.action.get.GetRequest;
import org.elasticsearch.action.get.GetResponse;
import org.elasticsearch.action.index.IndexRequest;
import org.elasticsearch.action.index.IndexResponse;
import org.elasticsearch.action.search.SearchRequest;
import org.elasticsearch.action.search.SearchResponse;
import org.elasticsearch.action.update.UpdateRequest;
import org.elasticsearch.action.update.UpdateResponse;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.xcontent.XContentType;
import org.elasticsearch.index.query.MatchQueryBuilder;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.*;
import com.elasticsearch.entity.Employee;

@Component
public class ESUtil {

    @Autowired
    private RestHighLevelClient client;

    private final ObjectMapper mapper = new ObjectMapper();

    private static final String INDEX = "employees";

    // ‚úÖ Index (Create/Update)
    public String indexDocument(Employee employee) throws IOException {
        String json = mapper.writeValueAsString(employee);
        IndexRequest request = new IndexRequest(INDEX)
                .id(employee.getId())
                .source(json, XContentType.JSON);

        IndexResponse response = client.index(request, RequestOptions.DEFAULT);
        return response.getResult().name();
    }

    // üîç Get
    public Employee getDocument(String id) throws IOException {
        GetRequest getRequest = new GetRequest(INDEX, id);
        GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);

        if (getResponse.isExists()) {
            return mapper.readValue(getResponse.getSourceAsString(), Employee.class);
        } else {
            return null;
        }
    }

    // üîÑ Update (Partial)
    public String updateDocument(String id, Map<String, Object> updateMap) throws IOException {
        UpdateRequest request = new UpdateRequest(INDEX, id)
                .doc(updateMap);
        UpdateResponse response = client.update(request, RequestOptions.DEFAULT);
        return response.getResult().name();
    }

    // ‚ùå Delete
    public String deleteDocument(String id) throws IOException {
        DeleteRequest request = new DeleteRequest(INDEX, id);
        DeleteResponse response = client.delete(request, RequestOptions.DEFAULT);
        return response.getResult().name();
    }

    // üîé Search (match)
    public List<Employee> searchByField(String field, String value) throws IOException {
        SearchRequest searchRequest = new SearchRequest(INDEX);
        SearchSourceBuilder builder = new SearchSourceBuilder();
        builder.query(new MatchQueryBuilder(field, value));
        searchRequest.source(builder);

        SearchResponse response = client.search(searchRequest, RequestOptions.DEFAULT);

        List<Employee> employees = new ArrayList<>();
        for (SearchHit hit : response.getHits()) {
            Employee e = mapper.readValue(hit.getSourceAsString(), Employee.class);
            employees.add(e);
        }
        return employees;
    }
}


---

üíº 5Ô∏è‚É£ Service ‚Äî EmployeeService.java

package com.elasticsearch.service;

import com.elasticsearch.entity.Employee;
import com.elasticsearch.util.ESUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@Service
public class EmployeeService {

    @Autowired
    private ESUtil esUtil;

    public String saveEmployee(Employee emp) throws IOException {
        return esUtil.indexDocument(emp);
    }

    public Employee getEmployee(String id) throws IOException {
        return esUtil.getDocument(id);
    }

    public String updateEmployee(String id, Map<String, Object> fields) throws IOException {
        return esUtil.updateDocument(id, fields);
    }

    public String deleteEmployee(String id) throws IOException {
        return esUtil.deleteDocument(id);
    }

    public List<Employee> searchByName(String name) throws IOException {
        return esUtil.searchByField("name", name);
    }
}


---

üåê 6Ô∏è‚É£ Controller ‚Äî EmployeeController.java

package com.elasticsearch.controller;

import com.elasticsearch.entity.Employee;
import com.elasticsearch.service.EmployeeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/employees")
public class EmployeeController {

    @Autowired
    private EmployeeService service;

    @PostMapping
    public String save(@RequestBody Employee emp) throws IOException {
        return service.saveEmployee(emp);
    }

    @GetMapping("/{id}")
    public Employee get(@PathVariable String id) throws IOException {
        return service.getEmployee(id);
    }

    @PatchMapping("/{id}")
    public String update(@PathVariable String id, @RequestBody Map<String, Object> fields) throws IOException {
        return service.updateEmployee(id, fields);
    }

    @DeleteMapping("/{id}")
    public String delete(@PathVariable String id) throws IOException {
        return service.deleteEmployee(id);
    }

    @GetMapping("/search")
    public List<Employee> search(@RequestParam String name) throws IOException {
        return service.searchByName(name);
    }
}


---

üß™ 7Ô∏è‚É£ Test with Postman or curl

‚ûï Index

POST http://localhost:8080/api/employees
{
  "id": "1",
  "name": "Rushi",
  "designation": "Developer",
  "skills": ["Spring Boot", "Docker"]
}

üîç Get

GET http://localhost:8080/api/employees/1

üîÑ Update

PATCH http://localhost:8080/api/employees/1
{
  "designation": "Senior Developer"
}

‚ùå Delete

DELETE http://localhost:8080/api/employees/1

üîé Search

GET http://localhost:8080/api/employees/search?name=Rushi


---

üß≠ Summary

Operation	API Used	Method

Index	IndexRequest	client.index()
Get	GetRequest	client.get()
Update	UpdateRequest	client.update()
Delete	DeleteRequest	client.delete()
Search	SearchRequest + MatchQueryBuilder	client.search()



---

üí° Next Steps

Once you‚Äôre comfortable with this:

I‚Äôll show you how to add fuzzy search, autocomplete, and bulk operations (real-world ES 7.x use cases).

Then we‚Äôll migrate this to Elasticsearch 8.x using the new ElasticsearchClient.



---

Would you like me to extend this same ES 7.x project with fuzzy search + prefix search + bulk insert/search next? That‚Äôs usually the next phase after CRUD in enterprise setups.

