Got it âœ… Rushi â€” letâ€™s build this Employee Service with MySQL + Elasticsearch (search + fuzzy + autocomplete + aggregations) fully from scratch using Spring Boot 3.x + Java 21.


---

ðŸ”¹ Step 1: Spring Initializr Setup

Dependencies to select:

Spring Web

Spring Data JPA

Spring Data Elasticsearch

MySQL Driver

Lombok (optional, for boilerplate reduction)


Project:

Group: com.example
Artifact: employee-search
Name: employee-search
Java: 21
Spring Boot: 3.x


---

ðŸ”¹ Step 2: application.yml

Configure MySQL + Elasticsearch.

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/employees_db
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true

  elasticsearch:
    uris: http://localhost:9200
    username: elastic
    password: changeme

server:
  port: 8081


---

ðŸ”¹ Step 3: Employee Entity (MySQL)

@Entity
@Table(name = "employees")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class EmployeeEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;
    private String designation;
    private int yearsOfExperience;

    @ElementCollection
    private List<String> skills;
}


---

ðŸ”¹ Step 4: Employee Document (Elasticsearch)

@Document(indexName = "employees")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class EmployeeDocument {

    @Id
    private String id;
    private String name;
    private String email;
    private String designation;
    private int yearsOfExperience;
    private List<String> skills;
}


---

ðŸ”¹ Step 5: Repositories

MySQL Repository

@Repository
public interface EmployeeJpaRepository extends JpaRepository<EmployeeEntity, Long> {
}

Elasticsearch Repository

@Repository
public interface EmployeeElasticRepository extends ElasticsearchRepository<EmployeeDocument, String> {

    // Fuzzy search by name
    @Query("{\"match\": {\"name\": {\"query\": \"?0\", \"fuzziness\": \"AUTO\"}}}")
    List<EmployeeDocument> fuzzySearchByName(String name);

    // Fuzzy search by skills
    @Query("{\"match\": {\"skills\": {\"query\": \"?0\", \"fuzziness\": \"AUTO\"}}}")
    List<EmployeeDocument> fuzzySearchBySkill(String skill);

    // Autocomplete by name
    @Query("{\"prefix\": {\"name\": \"?0\"}}")
    List<EmployeeDocument> autocompleteByName(String prefix);

    // Autocomplete by skill
    @Query("{\"prefix\": {\"skills\": \"?0\"}}")
    List<EmployeeDocument> autocompleteBySkill(String prefix);
}


---

ðŸ”¹ Step 6: Aggregation Repository

@Repository
public class EmployeeAggregationRepository {

    private final ElasticsearchOperations operations;

    public EmployeeAggregationRepository(ElasticsearchOperations operations) {
        this.operations = operations;
    }

    public Map<String, Long> countByDesignation() {
        NativeQuery query = NativeQuery.builder()
                .withAggregation("designationAgg", a -> a.terms(t -> t.field("designation.keyword")))
                .build();

        SearchHits<EmployeeDocument> hits = operations.search(query, EmployeeDocument.class);
        Map<String, Long> result = new HashMap<>();
        Terms designationAgg = hits.getAggregations().get("designationAgg");
        designationAgg.getBuckets().forEach(bucket ->
                result.put(bucket.getKeyAsString(), bucket.getDocCount()));
        return result;
    }

    public Map<String, Long> topSkills() {
        NativeQuery query = NativeQuery.builder()
                .withAggregation("skillsAgg", a -> a.terms(t -> t.field("skills.keyword")))
                .build();

        SearchHits<EmployeeDocument> hits = operations.search(query, EmployeeDocument.class);
        Map<String, Long> result = new HashMap<>();
        Terms skillsAgg = hits.getAggregations().get("skillsAgg");
        skillsAgg.getBuckets().forEach(bucket ->
                result.put(bucket.getKeyAsString(), bucket.getDocCount()));
        return result;
    }

    public double averageExperience() {
        NativeQuery query = NativeQuery.builder()
                .withAggregation("avgExperience", a -> a.avg(avg -> avg.field("yearsOfExperience")))
                .build();

        SearchHits<EmployeeDocument> hits = operations.search(query, EmployeeDocument.class);
        Avg avg = hits.getAggregations().get("avgExperience");
        return avg.getValue();
    }
}


---

ðŸ”¹ Step 7: Service Layer

@Service
@RequiredArgsConstructor
public class EmployeeService {

    private final EmployeeJpaRepository mysqlRepo;
    private final EmployeeElasticRepository esRepo;
    private final EmployeeAggregationRepository aggRepo;

    public EmployeeEntity save(EmployeeEntity emp) {
        // Save in MySQL
        EmployeeEntity saved = mysqlRepo.save(emp);

        // Sync to Elasticsearch
        EmployeeDocument doc = new EmployeeDocument(
                saved.getId().toString(),
                saved.getName(),
                saved.getEmail(),
                saved.getDesignation(),
                saved.getYearsOfExperience(),
                saved.getSkills()
        );
        esRepo.save(doc);

        return saved;
    }

    public List<EmployeeDocument> fuzzyByName(String name) {
        return esRepo.fuzzySearchByName(name);
    }

    public List<EmployeeDocument> fuzzyBySkill(String skill) {
        return esRepo.fuzzySearchBySkill(skill);
    }

    public List<EmployeeDocument> autocompleteName(String prefix) {
        return esRepo.autocompleteByName(prefix);
    }

    public List<EmployeeDocument> autocompleteSkill(String prefix) {
        return esRepo.autocompleteBySkill(prefix);
    }

    public Map<String, Long> countByDesignation() {
        return aggRepo.countByDesignation();
    }

    public Map<String, Long> topSkills() {
        return aggRepo.topSkills();
    }

    public double averageExperience() {
        return aggRepo.averageExperience();
    }
}


---

ðŸ”¹ Step 8: Controller

@RestController
@RequestMapping("/employees")
@RequiredArgsConstructor
public class EmployeeController {

    private final EmployeeService service;

    @PostMapping
    public EmployeeEntity addEmployee(@RequestBody EmployeeEntity emp) {
        return service.save(emp);
    }

    @GetMapping("/fuzzy/name/{name}")
    public List<EmployeeDocument> fuzzyByName(@PathVariable String name) {
        return service.fuzzyByName(name);
    }

    @GetMapping("/fuzzy/skill/{skill}")
    public List<EmployeeDocument> fuzzyBySkill(@PathVariable String skill) {
        return service.fuzzyBySkill(skill);
    }

    @GetMapping("/autocomplete/name/{prefix}")
    public List<EmployeeDocument> autocompleteName(@PathVariable String prefix) {
        return service.autocompleteName(prefix);
    }

    @GetMapping("/autocomplete/skill/{prefix}")
    public List<EmployeeDocument> autocompleteSkill(@PathVariable String prefix) {
        return service.autocompleteSkill(prefix);
    }

    @GetMapping("/analytics/designation")
    public Map<String, Long> countByDesignation() {
        return service.countByDesignation();
    }

    @GetMapping("/analytics/skills")
    public Map<String, Long> topSkills() {
        return service.topSkills();
    }

    @GetMapping("/analytics/experience/avg")
    public double averageExperience() {
        return service.averageExperience();
    }
}


---

ðŸ”¹ Step 9: Run & Test

Add Employee

POST http://localhost:8081/employees
{
  "name": "Rushikesh Mane",
  "email": "rushikesh@deloitte.com",
  "designation": "Senior Developer",
  "yearsOfExperience": 5,
  "skills": ["Java", "Spring Boot", "Docker", "AWS"]
}

Fuzzy Search

GET http://localhost:8081/employees/fuzzy/skill/Sprng

Autocomplete

GET http://localhost:8081/employees/autocomplete/skill/Spr

Aggregations

GET http://localhost:8081/employees/analytics/designation
GET http://localhost:8081/employees/analytics/skills
GET http://localhost:8081/employees/analytics/experience/avg


---

âœ… This is a full scratch Spring Boot project that:

Saves employees in MySQL (system of record)

Indexes employees into Elasticsearch (for search/analytics)

Supports CRUD + fuzzy search + autocomplete + analytics



---

ðŸ‘‰ Do you want me to also include a Docker Compose file to run MySQL + Elasticsearch locally for testing?

